#! /usr/bin/env bash

###############################################################################
# Monitor DB2 with Nagios
# Copyright 2013 Andres Gomez Casanova
# https://github.com/angoca/monitor-db2-with-nagios
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
###############################################################################

# This script queries the status of the instance by retrieving the port number
# or service name from the configuration, and then querying netstat to check if
# there is an associated service with that port.
#
# This script was based on the plugins written by Felipe Alkain de Souza.
# http://www.dbatodba.com/db2/scripts-db2/nagios-plugins
#
# In order to be used in Nagios, you have to configure the following.
#
# # 'check_instance_up' command definition
# define command {
#         command_name    check_instance_up
#         command_line    $USER1$/check_by_ssh -H $HOSTADDRESS$ -l nagios -C "scripts/check_instance_up -i '$ARG1$'"
# }
# define service{
#         host_name               db2server
#         service_description     Instance status
#         check_command           check_instance_up!/home/db2inst1
#         use                     generic-service
# }
#
# When using NRPE:
#
# In the database server:
#
# command[check_instance_up]=/home/nagios/scripts/check_instance_up -i /home/db2inst1
#
# Then modify the path according to your script location and instance home dir.
#
# In the Nagios server:
#
# define service{
#         host_name               db2server
#         service_description     Instance status
#         check_command           check_nrpe_1arg!check_instance_up
#         use                     generic-service
# }
#
# Parameters:
# -h | --help : Show the help of this script.
# -i | --instance : Home directory of the instance. Usually it is
#   /home/db2inst1
# -V | --version : Show the current version of this script.
# -v | --verbose : Execute the program in verbose mode.
#
# The exit codes are the standard for Nagios.
#
# 0 The plugin was able to check the service and it appeared to be functioning
#   properly.
# 1 The plugin was able to check the service, but it appeared to be above some
#   "warning" threshold or did not appear to be working properly.
# 2 The plugin detected that either the service was not running or it was above
#   some "critical" threshold.
# 3 Invalid command line arguments were supplied to the plugin or low-level
#   failures internal to the plugin (such as unable to fork, or open a tcp
#   socket) that prevent it from performing the specified operation.
#   Higher-level errors (such as name resolution errors, socket timeouts, etc)
#   are outside of the control of plugins and should generally NOT be reported
#   as UNKNOWN states.
#
# Author: Andres Gomez Casanova
# Version: v1.0 2013-01-18

# Flag for debugging.
#set -xv

# Locale to print messages in English. Prevent language problems.
export LANG=en_US

# Version of this script.
function print_revision {
  echo Andres Gomez Casanova - AngocA
  echo v1.0 2013-01-18
}
# Function to show the help
function print_usage {
  echo "Usage: $1 { -i instanceHomeDirectory # -h # -V } [ -v ]"
}

function print_help {
  print_revision
  print_usage $1
  # Max 80 chars width.
  /bin/cat <<__EOT
This script checks if the instance is active by querying netstats.
-h | --help
   Shows the current documentation.
-i | --instance STRING
   Instance home directory. It is usually /home/db2inst1
-v | --verbose
   Executes the script in verbose mode (multiple times).
-V | --version
   Shows the current version of this script.
__EOT
}

# Variable to control the flow execution. Prevent Spaghetti code.
CONTINUE=true

# Nagios return codes
OK=0
WARNING=1
CRITICAL=2
UNKNOWN=3
# This is the returned code.
RETURN=$UNKNOWN

# Nagios Output
# Text output 80 chars | Optional Perf Data Line 1
# Long text Line 1
# Long text Line 2 | Optional Perf Data Line 2
# Optional Perf Data Line 3
OUTPUT=
PERFORMANCE=
LONG_OUTPUT=
LONG_PERFORMANCE=

APPL_NAME=$(basename ${0})

if [[ $# -eq 0 ]] ; then
  print_usage $APPL_NAME
  RETURN=$UNKNOWN
  CONTINUE=false
fi

# The following requieres GNU getopt. See the following discusion.
# http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options

TEMP=$(getopt -o hVvi: --long help,version,verbose,instance: \
             -n $APPL_NAME -- "$@")

if [[ $? -ne 0 ]] ; then
  print_usage $APPL_NAME
  RETURN=$UNKNOWN
  CONTINUE=false
fi

if [[ $CONTINUE == true ]] ; then
  # Note the quotes around $TEMP: they are essential!
  eval set -- "$TEMP"

  HELP=false
  VERSION=false
  # Verbosity level
  VERBOSE=0
  INSTANCE_HOME=
  while true; do
    case "$1" in
      -h | --help ) HELP=true; shift ;;
      -i | --instance ) INSTANCE_HOME=$(echo $2 | cut -d' ' -f1) ; shift 2 ;;
      -V | --version ) VERSION=true; shift ;;
      -v | --verbose ) VERBOSE=$(( $VERBOSE + 1 )); shift ;;
      -- ) shift; break ;;
      * ) break ;;
    esac
  done
fi

if [[ $VERBOSE -ge 2 ]] ; then
  ECHO="help:$HELP, version:$VERSION, verbose:$VERBOSE, "
  ECHO=$ECHO"directory:$INSTANCE_HOME"
  echo $ECHO
fi

if [[ $CONTINUE == true && $HELP == true ]] ; then
  print_help $APPL_NAME
  RETURN=$UNKNOWN
  CONTINUE=false
fi

if [[ $CONTINUE == true && $VERSION == true ]] ; then
  print_revision $APPL_NAME
  RETURN=$UNKNOWN
  CONTINUE=false
fi

if [[ $CONTINUE == true && $INSTANCE_HOME == "" ]] ; then
  print_usage $APPL_NAME
  RETURN=$UNKNOWN
  CONTINUE=false
fi

if [[ $CONTINUE == true ]] ; then
  # Trims the characters.
  INSTANCE_HOME=$(echo $INSTANCE_HOME | cut -d' ' -f1)

  if [[ -d $INSTANCE_HOME && -e $INSTANCE_HOME/sqllib/db2profile ]] ; then
    # Load the DB2 profile.
    . $INSTANCE_HOME/sqllib/db2profile
  else
    OUTPUT="Instance directory is invalid."
    RETURN=$UNKNOWN
    CONTINUE=false
  fi
fi

if [[ $CONTINUE == true ]] ; then
  COMMAND_PID="db2pd -edus"
  if [[ $VERBOSE -ge 2 ]] ; then
    echo "COMMAND: $COMMAND_PID"
  fi
  OUTPUT_PID=$($COMMAND_PID | grep 'db2sysc PID' | cut -d' ' -f3)
  if [[ $VERBOSE -ge 3 ]] ; then
    echo "Result: $OUTPUT_PID"
  fi
  if [[ $OUTPUT_PID != "" && $OUTPUT_PID =~ ^[0-9]+$ ]] ; then
    OUTPUT_PS=$(ps -ef | grep db2sysc | grep $OUTPUT_PID)
  fi

  COMMAND_CONF="db2 get dbm cfg"
  if [[ $VERBOSE -ge 2 ]] ; then
    echo "COMMAND: $COMMAND_CONF"
  fi
  OUTPUT_CONF=$($COMMAND_CONF)
  # Gets the service name configure in the instance. It could be a text or a number.
  SVCNAME=$(printf '%s\n' "$OUTPUT_CONF" | grep SVCENAME | cut -d= -f2 | sed "s/^[ \t]*//")
  # Copies the value in portnum, but checks later.
  PORTNUM=$SVCNAME

  if ! [[ $SVCNAME =~ ^[0-9]+$ ]] ; then
    # SVCNAME is a text, thus replace portnum.
    REGEXP="^$SVCNAME\s"
    PORTNUM=$(grep -P $REGEXP /etc/services | awk '{print $2}' | cut -d/ -f1)
  fi

  MAX_DB=$(printf '%s\n' "$OUTPUT_CONF" | awk '/NUMDB/ {print $9}')
  if [[ $VERBOSE -ge 3 ]] ; then
    echo "Result: $MAX_DB"
  fi

  # Checks if the port has a active service associated.
  if [[ $PORTNUM != "" ]] ; then
    PROC=$(netstat -na | grep $PORTNUM | wc -l)
  fi

  if [[ $OUTPUT_PID == "" || ! $OUTPUT_PID =~ ^[0-9]+$ ]] ; then
    OUTPUT="Instance is not started (not listed in EDUs). "
    PERFORMANCE="'Started Instance'=0.1;;0.4 "
    RETURN=$UNKNOWN
  else
    OUTPUT="PID: $OUTPUT_PID. "
  fi
  if [[ $SVCNAME == "" ]] ; then
    OUTPUT="${OUTPUT}TCP port not defined or instance output is invalid."
    PERFORMANCE="'Started Instance'=0.1;;0.4 "
    RETURN=$CRITICAL
  elif [[ $PORTNUM == "" || ! $PORTNUM =~ ^[0-9]+$ ]] ; then
    OUTPUT="${OUTPUT}Problem retrieving port number."
    PERFORMANCE="'Started Instance'=0.2;;0.4 "
    RETURN=$CRITICAL
  elif [[ ! $PROC =~ ^[0-9]+$ ]] ; then
    OUTPUT="${OUTPUT}Weird situation."
    PERFORMANCE="'Started Instance'=0.0;;0.4 "
    RETURN=$UNKNOWN
  else
    if [[ $PROC -eq "0" ]] ; then
      OUTPUT="Instance at $INSTANCE_HOME is down."
      PERFORMANCE="'Started Instance'=0.3;;0.4 "
      RETURN=$CRITICAL
    elif [[ ! $OUTPUT_PID =~ ^[0-9]+$ ]] ; then
      OUTPUT="Instance at $INSTANCE_HOME is up but the PID is unknown"
      PERFORMANCE="'Started Instance'=${MAX_DB};;0.4 "
      RETURN=$WARNING
    else
      OUTPUT="Instance at $INSTANCE_HOME is up (PID $OUTPUT_PID)."
      PERFORMANCE="'Started Instance'=$MAX_DB;;0.4 "
      RETURN=$OK
    fi
  fi

  COMMAND_ACTIVE="db2 list active databases"
  if [[ $VERBOSE -ge 2 ]] ; then
    echo "Command: $COMMAND_ACTIVE"
  fi

  ACTIVE=$($COMMAND_ACTIVE | grep 'Database name' | wc -l)
  if [[ $VERBOSE -ge 2 ]] ; then
    echo "Result: $ACTIVE"
  fi

  LONG_OUTPUT="There are $ACTIVE active databases"
  LONG_PERFORMANCE="'Active Databases'=$ACTIVE;;0.2 "
fi

# Prints the output.
if [[ $OUTPUT == "" ]] ; then
  OUTPUT="Note: The test was not executed."
fi
# Builds the output.
echo "$OUTPUT|$PERFORMANCE
$LONG_OUTPUT|$LONG_PERFORMANCE"
# Returns the error code.
if [[ $VERBOSE -ge 2 ]] ; then
  echo "Return code: $RETURN"
fi
exit $RETURN
